<?php
/**
 * Plugin Name:       Gutenberg Collaborative Editing
 * Description:       A plugin to enhance Gutenberg with collaborative editing features.
 * Requires at least: 6.0
 * Requires PHP:      7.4
 * Version:           0.0.1
 * Author:            DotOrg
 * License:           GPL-2.0-or-later
 * License URI:       https://www.gnu.org/licenses/gpl-2.0.html
 * Text Domain:       gutenberg-collaborative-editing
 *
 * @package           gce
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit; // Exit if accessed directly.
}

/**
 * Enqueue editor assets for the plugin.
 *
 * This function includes the compiled JS and CSS files in the block editor.
 * It uses the asset file generated by @wordpress/scripts to manage dependencies and versions.
 */
function gce_enqueue_editor_assets() {
	$asset_file_path = plugin_dir_path( __FILE__ ) . 'build/index.asset.php';

	if ( ! file_exists( $asset_file_path ) ) {
	    return;
	}

    $asset_file = include $asset_file_path;

    wp_enqueue_script(
        'gutenberg-collaborative-editing-editor-script',
        plugins_url( 'build/index.js', __FILE__ ),
        $asset_file['dependencies'],
        $asset_file['version'],
        true
    );

    // Localize script with sync data
    wp_localize_script(
        'gutenberg-collaborative-editing-editor-script',
        'gceSync',
        array(
            'ajaxUrl' => admin_url( 'admin-ajax.php' ),
            'nonce' => wp_create_nonce( 'gutenberg_sync_nonce' ),
            'postId' => get_the_ID(),
            'currentUserId' => get_current_user_id(),
            'syncAction' => 'gce_sync_content',
            'pollAction' => 'gce_poll_content',
        )
    );

    if ( is_rtl() ) {
        wp_enqueue_style(
            'gutenberg-collaborative-editing-editor-style',
            plugins_url( 'build/style-index-rtl.css', __FILE__ ),
            [],
            $asset_file['version']
        );
    } else {
        wp_enqueue_style(
            'gutenberg-collaborative-editing-editor-style',
            plugins_url( 'build/style-index.css', __FILE__ ),
            [],
            $asset_file['version']
        );
    }
}
add_action( 'enqueue_block_editor_assets', 'gce_enqueue_editor_assets' );

/**
 * AJAX handler for content sync from lock holders
 */
function gce_handle_sync_content() {
    check_ajax_referer( 'gutenberg_sync_nonce', 'nonce' );
    
    $post_id = intval( $_POST['post_id'] ?? 0 );
    $content = json_decode( wp_unslash( $_POST['content'] ?? '{}' ), true );
    
    if ( ! $post_id || ! $content ) {
        wp_send_json_error( array( 'message' => 'Invalid request data' ) );
        return; // unreachable since we die() in wp_send_json_error(), just added for readability
    }
    
    // Verify user has lock on this post
    if ( ! current_user_can( 'edit_post', $post_id ) ) {
        wp_send_json_error( array( 'message' => 'Permission denied' ) );
        return; // unreachable since we die() in wp_send_json_error(), just added for readability
    }
    
    $lock = wp_check_post_lock( $post_id );
    if ( $lock ) {
        wp_send_json_error( array( 'message' => 'Post is locked by another user' ) );
        return; // unreachable since we die() in wp_send_json_error(), just added for readability
    }
    
    // Store content in transient (expires in 1 hour)
    $transient_key = "gce_sync_content_{$post_id}";
    $sync_data = array(
        'content' => $content,
        'timestamp' => time(),
        'post_id' => $post_id,
        'user_id' => get_current_user_id()
    );
    set_transient( $transient_key, $sync_data, HOUR_IN_SECONDS );
    
    wp_send_json_success( array(
        'timestamp' => time(),
        'message' => 'Content synced successfully'
    ) );
}
add_action( 'wp_ajax_gce_sync_content', 'gce_handle_sync_content' );

/**
 * AJAX handler for content polling from non-lock holders
 */
function gce_handle_poll_content() {
    check_ajax_referer( 'gutenberg_sync_nonce', 'nonce' );
    
    $post_id = intval( $_GET['post_id'] ?? 0 );
    $last_timestamp = intval( $_GET['last_timestamp'] ?? 0 );
    
    if ( ! $post_id ) {
        wp_send_json_error( array( 'message' => 'Missing post_id' ) );
        return; // unreachable since we die() in wp_send_json_error(), just added for readability
    }
    
    if ( ! current_user_can( 'edit_post', $post_id ) ) {
        wp_send_json_error( array( 'message' => 'Permission denied' ) );
        return; // unreachable since we die() in wp_send_json_error(), just added for readability
    }
    
    // Long polling implementation
    $max_wait = 30; // 30 seconds max wait
    $check_interval = 0.1; // Check every 100ms for much faster response
    $start_time = microtime(true); // Use microtime for better precision
    
    while ( ( microtime(true) - $start_time ) < $max_wait ) {
        $transient_key = "gce_sync_content_{$post_id}";
        
        // Directly query the database to bypass any caching layers.
        global $wpdb;
        $option_name = '_transient_' . $transient_key;
        $value = $wpdb->get_var( $wpdb->prepare( "SELECT option_value FROM $wpdb->options WHERE option_name = %s", $option_name ) );
        $sync_data = $value ? unserialize( $value ) : false;
    
        if ( $sync_data && $sync_data['timestamp'] > $last_timestamp ) {
            wp_send_json_success( array(
                'content' => $sync_data,
                'has_update' => true
            ) );
            return; // unreachable since we die() in wp_send_json_success(), just added for readability
        }
        
        // Sleep for check interval to prevent excessive CPU usage
        usleep( $check_interval * 1000000 ); // usleep takes microseconds
    }
    
    // No update found within timeout window
    wp_send_json_success( array(
        'content' => null,
        'has_update' => false
    ) );
}
add_action( 'wp_ajax_gce_poll_content', 'gce_handle_poll_content' );

/**
 * Cleanup expired transients.
 *
 * This function is designed to be run on a cron schedule. It fetches all transients
 * created by this plugin and lets WordPress's native `get_transient` function
 * handle the deletion of any that have expired.
 */
function gce_cleanup_expired_transients() {
	global $wpdb;

	// Find our transients that have expired.
	$sql = "SELECT REPLACE(option_name, '_transient_timeout_', '') as option_name FROM {$wpdb->options} WHERE option_name LIKE '_transient_timeout_gce_sync_content_%' AND option_value < " . intval( time() );
	$transients = $wpdb->get_col( $sql );

	if ( empty( $transients ) ) {
		return;
	}

	foreach ( $transients as $transient_option_name ) {
		delete_transient( $transient_key );
	}
}
add_action( 'gce_cleanup_transients_cron', 'gce_cleanup_expired_transients' );

/**
 * Schedule the cron job on plugin activation.
 */
function gce_schedule_cron() {
	if ( ! wp_next_scheduled( 'gce_cleanup_transients_cron' ) ) {
		wp_schedule_event( time(), 'daily', 'gce_cleanup_transients_cron' );
	}
}
register_activation_hook( __FILE__, 'gce_schedule_cron' );

/**
 * Unschedule the cron job on plugin deactivation.
 */
function gce_unschedule_cron() {
	$timestamp = wp_next_scheduled( 'gce_cleanup_transients_cron' );
	if ( $timestamp ) {
		wp_unschedule_event( $timestamp, 'gce_cleanup_transients_cron' );
	}
}
register_deactivation_hook( __FILE__, 'gce_unschedule_cron' );
